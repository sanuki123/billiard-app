<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Billiards Angle & Ghost Ball</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background:#111; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; color:#eee; }
    #tableWrap { position: relative; display:block; width:100%; }
    #tableImage, #table { width: 100%; height: auto; display:block; }
    #table { position:absolute; inset:0; touch-action:none; cursor:default; }
  </style>
</head>
<body>
  <div id="tableWrap">
    <img id="tableImage" src="table.jpg" alt="billiards table background" />
    <canvas id="table"></canvas>
  </div>

  <script>
    const img = document.getElementById('tableImage');
    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d');

    const BALL_RADIUS_PX = 11;   // 球半径
    let btnHitBox = null;        // キャンバス内ボタンの当たり判定

    const state = {
      r: BALL_RADIUS_PX,
      cue:    { xRatio: 0.30, yRatio: 0.70 },
      obj:    { xRatio: 0.55, yRatio: 0.55 },
      pocket: { xRatio: 0.92, yRatio: 0.08 },
      dragging: null,
      showTangent: false,
    };

    img.addEventListener('load', () => {
      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      if (!w || !h) return;
      canvas.width = w;
      canvas.height = h;
      ['cue','obj','pocket'].forEach(k => {
        const p = pxFromRatio(state[k], w, h);
        internalSet(k, p.x, p.y);
      });
      draw();
    });

    img.addEventListener('error', () => { canvas.width = 1024; canvas.height = 590; draw(); });

    // ===== helpers =====
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function pxFromRatio(p, w, h){ return { x: p.xRatio * w, y: p.yRatio * h }; }
    function ratioFromPx(p, w, h){ return { xRatio: p.x / w, yRatio: p.y / h }; }
    function internalSet(key, x, y){
      const w = canvas.width, h = canvas.height, rad = state.r;
      x = clamp(x, rad, w - rad);
      y = clamp(y, rad, h - rad);
      Object.assign(state[key], ratioFromPx({x,y}, w, h));
    }
    function getPositions(){
      const w = canvas.width, h = canvas.height, r = state.r;
      return {
        cue:    pxFromRatio(state.cue, w, h),
        obj:    pxFromRatio(state.obj, w, h),
        pocket: pxFromRatio(state.pocket, w, h),
        r
      };
    }
    function signedAngle(ax, ay, bx, by){
      let diff = (Math.atan2(ay, ax) - Math.atan2(by, bx)) * 180 / Math.PI;
      if (diff > 180) diff -= 360;
      if (diff <= -180) diff += 360;
      return diff;
    }

    // === 角度差ラベル（固定16pxのまま） ===
    function drawLabel(text, x, y){
      ctx.font = '16px sans-serif';
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,.55)';
      ctx.strokeText(text, x, y);
      ctx.fillStyle = 'white';
      ctx.fillText(text, x, y);
    }
    function measureLabelWidth(text){
      ctx.save();
      ctx.font = '16px sans-serif';
      const w = ctx.measureText(text).width;
      ctx.restore();
      return w;
    }

    // ===== draw =====
    function draw(){
      const { cue, obj, pocket, r } = getPositions();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const opx = pocket.x - obj.x, opy = pocket.y - obj.y;
      const opl = Math.hypot(opx, opy) || 1e-6;
      const oux = opx / opl, ouy = opy / opl;

      const ghost = { x: obj.x - oux * (2*r), y: obj.y - ouy * (2*r) };

      // ※ 白帯のジオメトリ（終端座標）をここで計算して以後再利用
      const gdx = ghost.x - cue.x, gdy = ghost.y - cue.y;
      const glen = Math.hypot(gdx, gdy) || 1e-6;
      const gux = gdx / glen, guy = gdy / glen;
      const extendLen = Math.max(canvas.width, canvas.height) * 2;
      const endX = cue.x + gux * extendLen, endY = cue.y + guy * extendLen;

      // オブジェクト→ポケットの帯
      ctx.save();
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.lineWidth = 2 * r; ctx.strokeStyle = 'rgba(255,255,0,0.3)';
      ctx.beginPath(); ctx.moveTo(obj.x, obj.y); ctx.lineTo(pocket.x, pocket.y); ctx.stroke();
      ctx.restore();

      // （削除）キュー→ゴーストの白帯の“先頭側”描画は行わない
      // 代わりに最後に一度だけ描画して最前面にする

      const vShotX = ghost.x - cue.x, vShotY = ghost.y - cue.y;
      const vObjX  = pocket.x - obj.x, vObjY  = pocket.y - obj.y;
      const betaDeg = signedAngle(vShotX, vShotY, vObjX, vObjY);
      const betaAbs = Math.min(90, Math.abs(betaDeg));
      const displayIsZero = (Math.round(betaDeg * 10) / 10) === 0;

      // 接線（90°帯）
      if (state.showTangent && !displayIsZero){
        const perpCW  = { x:  ouy, y: -oux };
        const perpCCW = { x: -ouy, y:  oux };
        const t = (betaDeg >= 0) ? perpCW : perpCCW;
        const dirX = -t.x, dirY = -t.y;
        const tExtend = Math.max(canvas.width, canvas.height) * 2;
        ctx.save();
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.lineWidth = 2 * r; ctx.strokeStyle = 'rgba(200,200,200,0.3)';
        ctx.beginPath();
        ctx.moveTo(ghost.x, ghost.y);
        ctx.lineTo(ghost.x + dirX * tExtend, ghost.y + dirY * tExtend);
        ctx.stroke();
        ctx.restore();
      }

      // ボール描画
      function ball(x,y,rad,fill){
        ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2);
        ctx.fillStyle=fill; ctx.fill();
        ctx.lineWidth = 0.5; ctx.strokeStyle='#000'; ctx.stroke();
      }
      ball(cue.x, cue.y, r, 'white');
      ball(obj.x, obj.y, r, 'yellow');

      // ゴースト円
      ctx.save(); ctx.setLineDash([]);
      ctx.strokeStyle = 'red'; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.arc(ghost.x, ghost.y, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();

      // 接触点
      const contact = { x: obj.x - oux * r, y: obj.y - ouy * r };
      ctx.beginPath(); ctx.arc(contact.x, contact.y, Math.max(1.5, r*0.25/4), 0, Math.PI*2);
      ctx.fillStyle='#ff5964'; ctx.fill();

      // ポケット
      ctx.beginPath(); ctx.arc(pocket.x, pocket.y, r, 0, Math.PI*2);
      ctx.fillStyle='rgba(0,255,0,0.20)'; ctx.fill();
      ctx.lineWidth = 0.5; ctx.strokeStyle='blue'; ctx.stroke();

      // ラベル
      const thickness = Math.max(0, 1 - Math.sin(betaAbs * Math.PI / 180));
      const labelText = `角度差: ${betaDeg.toFixed(1)}°   厚み: ${thickness.toFixed(2)}`;
      drawLabel(labelText, 12, 24);

      // キャンバス内ボタン
      const labelWidth = measureLabelWidth(labelText);
      drawButton(12 + labelWidth + 20, 24);

      // 左上ミニ重なり図（白を上に＋接点表示）
      drawMiniOverlap(betaDeg, betaAbs);

      drawCueTopView();

      // ★ 白帯を最後に“1回だけ”描画（→ 先玉より上に表示）
      ctx.save();
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.lineWidth = 2 * r; 
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath();
      ctx.moveTo(cue.x, cue.y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();

      // 白帯の中央ガイド線（キュー中心 → 白帯終端）
      ctx.save();
      ctx.setLineDash([]);
      ctx.lineWidth = 0.2;
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(cue.x, cue.y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();
    }

    // === ミニ重なり図（白を上に描画。接点も表示） ===
    function drawMiniOverlap(betaDeg, betaAbs){
      const miniR = 60;
      const anchorX = 90, anchorY = 46;
      const cx1 = anchorX + miniR, cy = anchorY + miniR; // 手玉（白）
      const centerDist = 2 * miniR * Math.sin(betaAbs * Math.PI / 180);
      const sign = (betaDeg >= 0) ? -1 : 1;              // 左右切替
      const cx2 = cx1 + sign * centerDist;               // 先玉（黒）

      ctx.save();
      ctx.lineWidth = 1;

      // 先玉：黒枠（先に描く）
      ctx.strokeStyle = 'black';
      ctx.beginPath(); ctx.arc(cx2, cy, miniR, 0, Math.PI * 2); ctx.stroke();

      // 手玉：白枠（後に描いて上に重ねる）＋直径縦線
      ctx.strokeStyle = 'white';
      ctx.beginPath(); ctx.arc(cx1, cy, miniR, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx1, cy - miniR); ctx.lineTo(cx1, cy + miniR); ctx.stroke();

      // 接点（2球の中心の中点）を赤い点で表示
      const cxMid = (cx1 + cx2) / 2;
      ctx.beginPath();
      ctx.arc(cxMid, cy, 2, 0, Math.PI * 2);
      ctx.fillStyle = '#ff5964';
      ctx.fill();

      ctx.restore();
    }
    
    
    // === 手玉トップビュー（ミニ図の直下に表示） ===
	// ・円：手玉を真上から見た図（ミニ図と同サイズ）
	// ・線1：手玉の進行方向（cue → ghost の単位ベクトル）
	// ・線2：接点方向（ghost 中心 → 接点 ＝ obj→pocket 方向）
	function drawCueTopView(){
	  // 既存ミニ図の位置・サイズに合わせる
	  const miniR   = 60;
	  const anchorX = 90, anchorY = 46;
	  // ミニ図（上）より少し下へオフセット
	  const gapY    = 20;
	  const centerX = anchorX + miniR;
	  const centerY = anchorY + (miniR * 2) + gapY + miniR;

	  // 現在の配置から必要なベクトルを再計算（他のロジックは変更しない）
	  const { cue, obj, pocket, r } = getPositions();

	  // obj→pocket の単位ベクトル（接点方向の基準）
	  const opx = pocket.x - obj.x, opy = pocket.y - obj.y;
	  const opl = Math.hypot(opx, opy) || 1e-6;
	  const oux = opx / opl,          ouy = opy / opl;

	  // ゴースト中心
	  const ghost = { x: obj.x - oux * (2*r), y: obj.y - ouy * (2*r) };

	  // 手玉の進行方向（cue→ghost）
	  const sdx = ghost.x - cue.x, sdy = ghost.y - cue.y;
	  const sdl = Math.hypot(sdx, sdy) || 1e-6;
	  const sux = sdx / sdl,           suy = sdy / sdl;

	  // 接点は obj から半径 r だけポケット方向へ戻した点
	  // ゴースト中心から接点への方向は +ou（長さ r）
	  const cux = oux, cuy = ouy;

	  ctx.save();
	  ctx.lineWidth = 1;

	  // 円（手玉）
	  ctx.strokeStyle = 'white';
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, miniR, 0, Math.PI * 2);
	  ctx.stroke();

	  // 中心点（視認性用・小さめ）
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
	  ctx.fillStyle = 'white';
	  ctx.fill();

	  // 線1：進行方向（白）… cue→ghost の向き
	  ctx.beginPath();
	  ctx.moveTo(centerX, centerY);
	  ctx.lineTo(centerX + sux * miniR, centerY + suy * miniR);
	  ctx.strokeStyle = 'white';
	  ctx.lineWidth = 2;
	  ctx.stroke();

	  // 線2：接点方向（赤）… ghost 中心→接点 の向き（＝ obj→pocket の向き）
	  ctx.beginPath();
	  ctx.moveTo(centerX, centerY);
	  ctx.lineTo(centerX + cux * miniR, centerY + cuy * miniR);
	  ctx.strokeStyle = '#ff5964';
	  ctx.lineWidth = 2;
	  ctx.stroke();

	  ctx.restore();
	}

    

    // === キャンバス内ボタン（固定16px） ===
    function drawButton(x, y){
      const text = `[手玉の進行方向:${state.showTangent ? 'ON' : 'OFF'}]`;
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#4af';
      ctx.fillText(text, x, y);

      const m = ctx.measureText(text);
      const ascent  = m.actualBoundingBoxAscent  ?? 12;
      const descent = m.actualBoundingBoxDescent ?? 4;
      btnHitBox = { x, y: y - ascent, w: m.width, h: ascent + descent };
    }

    function getPointerPos(evt){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x:(evt.clientX-rect.left)*scaleX, y:(evt.clientY-rect.top)*scaleY };
    }
    function hit(pt, c, rad){ return Math.hypot(pt.x-c.x, pt.y-c.y)<=rad+6; }

    function onPointerDown(e){
      const { cue,obj,pocket,r }=getPositions();
      const pt=getPointerPos(e);
      if (hitBoxHit(pt)) {
        state.showTangent = !state.showTangent; // ボタントグル
        draw();
        return;
      }
      if (hit(pt,cue,r)) state.dragging='cue';
      else if (hit(pt,obj,r)) state.dragging='obj';
      else if (hit(pt,pocket,r)) state.dragging='pocket';
      if (state.dragging) canvas.setPointerCapture(e.pointerId);
    }
    function onPointerMove(e){
      if (!state.dragging) return;
      const pt=getPointerPos(e);
      internalSet(state.dragging, pt.x, pt.y); draw();
    }
    function onPointerUp(e){ state.dragging=null; try{canvas.releasePointerCapture(e.pointerId);}catch(_){} }

    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointerleave',()=>state.dragging=null);

    function hitBoxHit(pt){
      if (!btnHitBox) return false;
      return pt.x >= btnHitBox.x && pt.x <= btnHitBox.x + btnHitBox.w &&
             pt.y >= btnHitBox.y && pt.y <= btnHitBox.y + btnHitBox.h;
    }

    window.addEventListener('resize', draw);

    function pxFromRatio(p,w,h){ return { x:p.xRatio*w, y:p.yRatio*h }; }
    function ratioFromPx(p,w,h){ return { xRatio:p.x/w, yRatio:p.y/h }; }
  </script>
</body>
</html>
